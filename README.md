# Taller de TDD - Pruebas Unitarias

Este taller adapta el enfoque cl√°sico de **TDD** (Red ‚Üí Green ‚Üí Refactor) a una **Arquitectura Limpia (Clean Architecture)**. El objetivo es que las **pruebas unitarias** garanticen la calidad del **dominio** sin acoplarse a frameworks o infraestructura.

---

## üéØ Objetivos del taller

- Dise√±ar pruebas unitarias que ejerciten **reglas de negocio** (dominio) de forma **aislada**.  
- Aplicar TDD: **primero la prueba**, luego la implementaci√≥n m√≠nima, y **refactor** continuo.  
- Mantener **dependencias hacia adentro**: el dominio **no** conoce bases de datos, HTTP ni librer√≠as externas.  
- Escribir pruebas siguiendo el patr√≥n **AAA (Arrange ‚Äì Act ‚Äì Assert)** para mejorar legibilidad y mantenibilidad.  
- Definir **clases de equivalencia y valores l√≠mite** que permitan cubrir escenarios v√°lidos, inv√°lidos y bordes con un n√∫mero m√≠nimo de pruebas.  
- Expresar pruebas con **BDD (Given‚ÄìWhen‚ÄìThen)** para alinear el c√≥digo con el lenguaje de negocio y asegurar trazabilidad entre requisitos y validaci√≥n.

---

## üìë √çndice

- [Pruebas unitarias b√°sicas](#pruebas-unitarias-b√°sicas)
- [Ejercicio](#ejercicio-registradur√≠a)
- [TDD (Red ‚Üí Green ‚Üí Refactor)](#tdd-paso-a-paso-red--green--refactor)
- [Patr√≥n AAA (Arrange ‚Äì Act ‚Äì Assert)](#patr√≥n-aaa-arrange--act--assert)
- [Ejecutar pruebas](#ejecutar-las-pruebas)
- [Clases de equivalencia](#clases-de-equivalencia)
- [Gu√≠a avanzada de Pruebas Unitarias](#gu√≠a-avanzada-de-pruebas-unitarias)
- [Para entregar](#para-entregar)
- [Resumen del Taller de TDD](#resumen-del-Taller-de-TDD)
- [Recursos recomendados](#recursos-recomendados)

---

## PRUEBAS UNITARIAS B√ÅSICAS

---

### CREAR UN PROYECTO CON MAVEN

En el directorio de trabajo ejecutar el comando necesario para crear/generar un proyecto maven basado en un arquetipo:

```yml
Grupo (groupId): edu.unisabana.tyvs
Artefacto (artifactId): clasesequivalencia
Paquete (package): edu.unisabana.tyvs.tdd
archetypeArtifactId: maven-archetype-quickstart
```

üéì Si necesitas m√°s ayuda con la creaci√≥n de proyectos en Maven, revisa el [**Taller de Nivelaci√≥n**](https://github.com/CesarAVegaF312/DYAS-Taller_nivelacion).

---

### ACTUALIZAR Y CREAR DEPENDENCIAS EN EL PROYECTO

Busque en internet el repositorio central de ["maven"](https://mvnrepository.com/).

Busque el artefacto JUnit y entre a la versi√≥n m√°s nueva.

![](img/repo.png)

#### ‚ö†Ô∏è Nota importante 
Ingresar directamente a ["2. Junit"](https://mvnrepository.com/artifact/junit/junit).  

Ingrese a la pesta√±a de Maven y haga click en el texto de la dependencia para copiarlo al portapapeles.

Edite el archivo `pom.xml` y realice las siguientes actualizaciones:
- Agregue/Reemplace la dependencia copiada a la secci√≥n de dependencias.
- Cambie la versi√≥n del compilador de Java a la versi√≥n 8 (o el de su computador), agregando la secci√≥n `properties` antes de la secci√≥n de dependencias:

---

### Dependencias m√≠nimas (`pom.xml`)

```xml
  <properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <!-- JUnit 4 -->
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.13.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <version>3.2.5</version>
        <configuration>
          <useModulePath>false</useModulePath>
        </configuration>
      </plugin>
    </plugins>
  </build>
```

---

### COMPILAR Y EJECUTAR
Ejecute los comandos de Maven, 
```bash
mvn clean package
```
para compilar el proyecto y verificar que el proyecto se cre√≥ correctamente y los cambios realizados al archivo pom no generan inconvenientes.

Ejecute el comando para ejecutar las pruebas unitarias de un proyecto desde Maven y ejec√∫telo sobre el proyecto.

```bash
mvn clean test
```

 Se debe ejecutar la clase `AppTest` con resultado exitoso.

---

## EJERCICIO ‚ÄúREGISTRADUR√çA‚Äù

Se va a crear un proyecto base siguiendo la estructura de **Arquitectura Limpia (Clean Architecture)** para un cliente en la registradur√≠a, en el cual se registrar√°n personas con intenci√≥n de votar para las pr√≥ximas elecciones y se generar√°n los certificados electorales de aquellas personas cuyo voto sea v√°lido.

Se usar√° la clase *Person* que se describe m√°s adelante. El servicio de la registradur√≠a permitir√° registrar personas que sean votantes.

### REQUERIMIENTOS
- Solo se registrar√°n votantes v√°lidos.
- Solo se permite una inscripci√≥n por n√∫mero de documento.

---

### HACER EL ESQUELETO DE LA APLICACION

---

### Estructura propuesta (monom√≥dulo por paquetes)

```
src/
 ‚îú‚îÄ main/java/edu/unisabana/tyvs/
 ‚îÇ   ‚îú‚îÄ domain/
 ‚îÇ   ‚îÇ   ‚îú‚îÄ model/              # Person, Gender, RegisterResult
 ‚îÇ   ‚îÇ   ‚îî‚îÄ service/            # Registry
 ‚îî‚îÄ test/java/edu/unisabana/tyvs/
     ‚îú‚îÄ domain/
     ‚îÇ   ‚îî‚îÄ service/            # RegistryTest
```

> Tambi√©n puedes llevar esto a **multi-m√≥dulo Maven** m√°s estricto m√°s adelante. Para TDD, esta versi√≥n por paquetes es suficiente y simple.

---

#### Dominio: modelos

Cree el archivo `RegisterResult.java` en el directorio `edu.unisabana.tyvs.domain.model` con la enumeraci√≥n:

```java
package edu.unisabana.tyvs.domain.model;
public enum RegisterResult { VALID, DUPLICATED, INVALID }
```

Cree el archivo `Gender.java` en el paquete `edu.unisabana.tyvs.domain.model` con la enumeraci√≥n:

```java
package edu.unisabana.tyvs.domain.model;
public enum Gender { MALE, FEMALE, UNIDENTIFIED }
```

Cree el archivo `Person.java` en el paquete `edu.unisabana.tyvs.domain.model` con el siguiente contenido:

```java
package edu.unisabana.tyvs.domain.model;

public class Person {
    private final String name;
    private final int id;
    private final int age;
    private final Gender gender;
    private final boolean alive;

    public Person(String name, int id, int age, Gender gender, boolean alive) {
        this.name = name; this.id = id; this.age = age; this.gender = gender; this.alive = alive;
    }
    public String getName() { return name; }
    public int getId() { return id; }
    public int getAge() { return age; }
    public Gender getGender() { return gender; }
    public boolean isAlive() { return alive; }
}
```

---

#### Dominio: caso de uso (Servicio)

Cree el archivo `Registry.java` en el directorio `edu.unisabana.tyvs.domain.service` con el m√©todo `registerVoter`:

```java
package edu.unisabana.tyvs.domain.service;

import edu.unisabana.tyvs.domain.model.*;

public class Registry {

    public RegisterResult registerVoter(Person p) {
        // TODO Validate person and return real result.
        return RegisterResult.VALID;
    }
}
```

---

## TDD Paso a Paso (Red ‚Üí Green ‚Üí Refactor)

El ciclo TDD: Red ‚Üí Green ‚Üí Refactor es la pr√°ctica central de Desarrollo Guiado por Pruebas (Test-Driven Development) y consiste en tres pasos cortos y repetitivos:

### 1. RED (Rojo)
- Escribes una prueba unitaria nueva que describe el comportamiento que deseas.
- Como a√∫n no has implementado el c√≥digo (o la l√≥gica est√° incompleta), la prueba falla.

### 2. GREEN (Verde)
- Escribes la implementaci√≥n m√≠nima para que la prueba pase.
- No importa si el c√≥digo no es elegante todav√≠a, lo importante es que sea funcional.

### 3. REFACTOR (Refactorizar)
- Una vez todas las pruebas est√°n en verde, mejoras el c√≥digo:
  - Limpias duplicaci√≥n.
  - Renombras variables o m√©todos.
  - Ordenas condiciones.
  - Extraes constantes.
- Lo clave: no rompes pruebas existentes.

Todos los archivos relacionados espec√≠ficamente con los temas de pruebas deben ir bajo la carpeta `test`.

Adicional a esta practica de creacion de pruebas vamos a seguir el dise√±o de pruebas patr√≥n **AAA (Arrange ‚Äì Act ‚Äì Assert)**

## Patr√≥n AAA (Arrange ‚Äì Act ‚Äì Assert)

En el dise√±o de pruebas unitarias se recomienda estructurar cada m√©todo de prueba siguiendo el patr√≥n AAA:

### Arrange (Preparar)
- Se configuran los datos, objetos y estado inicial necesarios para la prueba.

### Act (Actuar)
- Se ejecuta la acci√≥n que queremos probar.

### Assert (Afirmar)
- Se verifican los resultados obtenidos frente a lo esperado.

#### ‚ö†Ô∏è Nota importante

‚úÖ Este patr√≥n mejora la legibilidad y mantenibilidad de las pruebas porque:

- Hace evidente qu√© se est√° preparando, qu√© se est√° probando y qu√© se est√° validando.
- Facilita que otros desarrolladores entiendan r√°pidamente el prop√≥sito de cada prueba.
- Evita que las pruebas se conviertan en ‚Äúcajas negras‚Äù dif√≠ciles de interpretar.

Empecemos ...

---

## EJECUTAR LAS PRUEBAS

---

### 1. RED: primera prueba (camino feliz)

Bajo la carpeta de pruebas, cree la clase `RegistryTest.java` en el directorio `edu.unisabana.tyvs.domain.service`:

```java
package edu.unisabana.tyvs.domain.service;

import edu.unisabana.tyvs.domain.model.*;
import org.junit.Assert;
import org.junit.Test;

public class RegistryTest {

    @Test
    public void shouldRegisterValidPerson() {
        // Arrange: preparar los datos y el objeto a probar
        Registry registry = new Registry();
        Person person = new Person("Ana", 1, 30, Gender.FEMALE, true);

        // Act: ejecutar la acci√≥n que queremos probar
        RegisterResult result = registry.registerVoter(person);

        // Assert: verificar el resultado esperado
        Assert.assertEquals(RegisterResult.VALID, result);
    }
}


```

### 2. GREEN: implementaci√≥n m√≠nima
Ya devuelve `VALID`, la prueba pasa.

---

#### ‚ö†Ô∏è Nota importante sobre ubicaci√≥n del `pom.xml`

Recuerde ejecutar todos los comandos Maven desde la carpeta **ra√≠z del proyecto**, donde se encuentra el archivo `pom.xml`.

---

Para correr las pruebas utilice:
```sh
mvn clean compile
```

Tambi√©n puede utilizar:
```sh
mvn clean test
```

---

Revise cu√°l es la diferencia.  
Tip: [Maven Lifecycle Phases](https://www.devopsschool.com/blog/maven-tutorials-maven-lifecycle-phases-goal).

---

Pero hagamos otra prueba ...

---

### 1. RED: persona muerta ‚Üí DEAD

```java

    @Test
    public void shouldRejectDeadPerson() {
        // Arrange: preparar los datos y el objeto a probar
        Registry registry = new Registry();
        Person dead = new Person("Carlos", 2, 40, Gender.MALE, false);

        // Act: ejecutar la acci√≥n que queremos probar
        RegisterResult result = registry.registerVoter(dead);

        // Assert: verificar el resultado esperado
        Assert.assertEquals(RegisterResult.DEAD, result);
    }

```

### 2. GREEN: implementaci√≥n m√≠nima
Agregue este c√≥digo a su clase `Registry.java` para ir complementando y haciendo mas robusta su clase.

```java

if (!p.isAlive()) return RegisterResult.DEAD;

```

### 3. Refactor
Refactorizando el c√≥digo.

```java
package edu.unisabana.tyvs.domain.service;

import edu.unisabana.tyvs.domain.model.Person;
import edu.unisabana.tyvs.domain.model.RegisterResult;

public class Registry {

    public RegisterResult registerVoter(Person p) {
        if (p == null) {
            return RegisterResult.INVALID; // regla defensiva
        }
        if (!p.isAlive()) {
            return RegisterResult.DEAD;
        }
        // implementaci√≥n m√≠nima para pasar las pruebas actuales
        return RegisterResult.VALID;
    }
}
```
y

```java
package edu.unisabana.tyvs.domain.model;

public enum RegisterResult {
    VALID, DUPLICATED, INVALID, DEAD
}
```

Ejecutar y validar nuevamente el resultado.

---

## CLASES DE EQUIVALENCIA

Antes de escribir pruebas conviene particionar el dominio de entrada en clases de [equivalencia](https://prezi.com/view/LyUYlz5nx2UmnKVMgSve/?referral_token=inUc7klnB3FN): grupos de valores que el sistema trata de la misma forma. Probar un representante por clase suele ser suficiente, y se refuerza con valores l√≠mite (los bordes entre clases), donde suelen aparecer errores. Piense en los casos de equivalencia que se pueden generar del ejercicio para la registradur√≠a dadas las condiciones.

Para `registerVoter(Person)` el espacio de entradas se define por los atributos del dominio (Definici√≥n de datos):

- Edad
  - Clase inv√°lida: `edad < 0` ‚Üí `INVALID_AGE` (l√≠mite: `-1`, borde inferior).
  - Clase ‚Äúmenor‚Äù: `0 ‚â§ edad < 18` ‚Üí `UNDERAGE` (l√≠mites: `17` y `18`).
  - Clase v√°lida: `18 ‚â§ edad ‚â§ 120` ‚Üí contribuye a `VALID` si dem√°s reglas pasan (l√≠mites: `18`, `120`).
  - Clase inv√°lida: `edad > 120` ‚Üí `INVALID_AGE` (l√≠mite: `121`).

- Estado de vida 
  - `alive = false` ‚Üí `DEAD` (independiente de la edad).
  - `alive = true` ‚Üí contin√∫a evaluaci√≥n de edad/duplicados.

- Identificador (unicidad)
  - Clase inv√°lida de formato (opcional seg√∫n tu enum): `id ‚â§ 0` ‚Üí `INVALID`/`INVALID_ID`.
  - Clase ‚Äúduplicado‚Äù: mismo `id` ya registrado ‚Üí `DUPLICATED`.
  - Clase ‚Äú√∫nico‚Äù: `id` no registrado ‚Üí contin√∫a evaluaci√≥n.

- Nulidad
  - `person == null` ‚Üí `INVALID` (validaci√≥n defensiva).

---

# Gu√≠a avanzada de Pruebas Unitarias

Las pruebas unitarias son la base de un plan de pruebas exhaustivo. Para alinearnos con las buenas pr√°cticas internacionales y los resultados de aprendizaje del curso, adem√°s de implementar las pruebas b√°sicas, se deben considerar los siguientes aspectos:

---

## 1. Planificaci√≥n de las pruebas
Define una **matriz de clases de equivalencia y valores l√≠mite** para `registerVoter`. 

Ejemplo:

| Caso | Entrada | Resultado esperado |
|------|---------|---------------------|
| Persona viva, edad 30, id √∫nico | (edad=30, vivo=true, id=1) | VALID |
| Persona muerta | (edad=45, vivo=false) | DEAD |
| Edad 17 | (edad=17, vivo=true) | UNDERAGE |
| Edad -1 | (edad=-1, vivo=true) | INVALID_AGE |
| Persona duplicada | (edad=25, id=777 dos veces) | DUPLICATED |

---

## 2. Cobertura de c√≥digo

Agrega **JaCoCo** para medir cobertura.  
Este plugin debe incluirse dentro de la secci√≥n `<build><plugins> ... </plugins></build>` del archivo `pom.xml`.

```xml
    <!-- (Opcional pero recomendado) JaCoCo para cobertura -->
    <build>
      <plugins>
        <plugin>
          <groupId>org.jacoco</groupId>
          <artifactId>jacoco-maven-plugin</artifactId>
          <version>0.8.12</version>
          <executions>
            <execution>
              <id>prepare-agent</id>
              <goals>
                <goal>prepare-agent</goal>
              </goals>
            </execution>
            <execution>
              <id>report</id>
              <phase>verify</phase>
              <goals>
                <goal>report</goal>
              </goals>
            </execution>
          </executions>
        </plugin>
      </plugins>
    </build>
```

Ejecuta:

```sh
mvn clean test
mvn jacoco:report
```

Revisa el archivo `target/site/jacoco/index.html`.

---

## 3. Robustez de las pruebas
La escritura de pruebas con **BDD (Behavior-Driven Development)** busca que los casos de prueba se expresen en un lenguaje cercano al negocio, entendible tanto para desarrolladores como para usuarios y analistas. A diferencia de las pruebas unitarias tradicionales, que se centran en m√©todos o clases, en BDD se describe el **comportamiento esperado del sistema** usando una narrativa estructurada en t√©rminos de Given‚ÄìWhen‚ÄìThen (Dado‚ÄìCuando‚ÄìEntonces). Esto facilita la comunicaci√≥n entre los diferentes actores de un proyecto, asegura que las pruebas est√©n alineadas con los requisitos funcionales y promueve que el c√≥digo se construya a partir de la especificaci√≥n del comportamiento deseado. En el marco de esta asignatura, BDD aporta claridad al proceso de validaci√≥n, ya que conecta directamente las reglas de negocio con la verificaci√≥n automatizada, fortaleciendo la robustez y la trazabilidad de las pruebas.

Ejemplo:

```gherkin
Escenario: Rechazar persona menor de edad
  Dado (Given) que existe una persona viva de 17 a√±os
  Cuando (When) intento registrarla
  Entonces (Then) el resultado debe ser UNDERAGE
```

---

## 4. Clases de equivalencia y escenarios BDD

La siguiente tabla combina los nombres de los tests unitarios (estilo t√©cnico en JUnit) con su respectiva especificaci√≥n en **BDD (Given‚ÄìWhen‚ÄìThen)**, de manera que se mantenga trazabilidad entre las reglas de negocio y las pruebas.

| Nombre del test (JUnit) | Escenario BDD (Given‚ÄìWhen‚ÄìThen) |
|--------------------------|----------------------------------|
| **shouldReturnInvalidWhenPersonIsNull** | **Given** la persona es `null` <br> **When** intento registrarla <br> **Then** el resultado debe ser `INVALID` |
| **shouldRejectWhenIdIsZeroOrNegative** | **Given** la persona tiene `id = 0` (o `id = -5`), edad 25 y est√° viva <br> **When** intento registrarla <br> **Then** el resultado debe ser `INVALID` |
| **shouldRejectUnderageAt17** | **Given** la persona tiene 17 a√±os, est√° viva y su id es v√°lido <br> **When** intento registrarla <br> **Then** el resultado debe ser `UNDERAGE` |
| **shouldAcceptAdultAt18** | **Given** la persona tiene 18 a√±os, est√° viva y su id es v√°lido <br> **When** intento registrarla <br> **Then** el resultado debe ser `VALID` |
| **shouldAcceptMaxAge120** | **Given** la persona tiene 120 a√±os, est√° viva y su id es v√°lido <br> **When** intento registrarla <br> **Then** el resultado debe ser `VALID` |
| **shouldRejectInvalidAgeOver120** | **Given** la persona tiene 121 a√±os, est√° viva y su id es v√°lido <br> **When** intento registrarla <br> **Then** el resultado debe ser `INVALID_AGE` |

> **Regla**: todas las pruebas unitarias se enfocan en **dominio**.

---

## 4. Gesti√≥n de defectos
Crea un archivo `defectos.md` para documentar fallos:

```
### Defecto 01
- Caso: edad -1
- Esperado: INVALID_AGE
- Obtenido: VALID
- Causa probable: falta de validaci√≥n en l√≠mites
- Estado: Abierto
```

---

## 5. Automatizaci√≥n e integraci√≥n (Opcional)
- Ejecuta las pruebas unitarias en cada commit con CI (GitHub Actions, Jenkins, GitLab CI).  
- Rechaza merges si `mvn test` falla.

---

## PARA ENTREGAR

- Repositorio Git con el proyecto y la URL de entrega.
- Archivo `.gitignore` (excluir `target`, archivos del IDE, etc.).
- Integrantes (archivo integrantes.txt o secci√≥n en el README).
- README con:
  - Instrucciones para compilar y correr pruebas (mvn clean test).
  - Descripci√≥n breve del dominio y reglas validadas.
  - Breve explicaci√≥n de **TDD (Red ‚Üí Green ‚Üí Refactor)** y **AAA** aplicada en el proyecto.
- Pruebas unitarias:
  - ‚â• 5 Clases de equivalencia y escenarios BDD.
  - Todas las pruebas escritas con **AAA (Arrange‚ÄìAct‚ÄìAssert)**.
- Nomenclatura clara de m√©todos (`should‚Ä¶`), y un solo assert principal por test (o varios con misma intenci√≥n).
- Cobertura:
  - Reporte **JaCoCo** adjunto (carpeta `target/site/jacoco/` o captura).
  - ‚â• 80% de cobertura global y ‚â• 80% en el paquete ‚Ä¶tdd.registry (si aplica).
- Evidencia de TDD:
  - Breve secci√≥n **‚ÄúHistoria TDD‚Äù** en el README indicando al menos 3 iteraciones: prueba nueva (Rojo) ‚Üí cambio m√≠nimo (Verde) ‚Üí refactor (mantener Verde).
  - Opcional: capturas o mensajes de commit que reflejen el ciclo (e.g., `test: add dead person rule (RED)`, `feat: minimal check alive (GREEN)`, `refactor: extract constants (REFACTOR)`).
- Matriz de pruebas:
  - Tabla con **clases de equivalencia** y **valores l√≠mite**: entradas, resultado esperado y test que lo cubre (nombre del m√©todo).
- Gesti√≥n de defectos:
  - Archivo `defectos.md` con al menos **1 defecto** real encontrado o simulado: caso, esperado vs. obtenido, causa probable, estado (Abierto/Cerrado).
- Calidad del c√≥digo:
  - Constantes extra√≠das (p. ej., `MIN_AGE`, `MAX_AGE`).
  - Sin **‚Äúc√≥digo muerto‚Äù**, sin duplicaci√≥n evidente en pruebas o producci√≥n.
  - Comentarios m√≠nimos y expresivos; preferir nombres autoexplicativos.
- Ejecuci√≥n reproducible:
  - Proyecto Maven ejecutable con `mvn clean test` sin pasos manuales adicionales.

- Reflexiona sobre:
  - ¬øQu√© escenarios no se cubrieron?
  - ¬øQu√© defectos reales detectaron los tests?
  - ¬øC√≥mo mejorar√≠as la clase `Registry` para facilitar su prueba?

---

# üî¥üü¢üîµ Historia TDD - Ciclo Red ‚Üí Green ‚Üí Refactor

Documentamos las iteraciones del ciclo TDD implementado para este proyecto:

## Iteraci√≥n 1: Persona V√°lida (Camino Feliz)

### üî¥ RED (Prueba que falla)
```java
@Test
public void shouldRegisterValidPerson() {
    Registry registry = new Registry();
    Person person = new Person("Ana", 1, 30, Gender.FEMALE, true);
    RegisterResult result = registry.registerVoter(person);
    Assert.assertEquals(RegisterResult.VALID, result);
}
```

### üü¢ GREEN (Implementaci√≥n m√≠nima)
```java
public RegisterResult registerVoter(Person p) {
    if (p == null) return RegisterResult.INVALID;
    if (p.getId() <= 0) return RegisterResult.INVALID;
    return RegisterResult.VALID;
}
```

### üîµ REFACTOR (Mejoras sin romper pruebas)
- Agregamos validaci√≥n de edad b√°sica
- Extraemos constantes: `MIN_VALID_AGE = 18`, `MAX_VALID_AGE = 120`

---

## Iteraci√≥n 2: Persona Muerta

### üî¥ RED
```java
@Test
public void shouldRejectDeadPerson() {
    Registry registry = new Registry();
    Person dead = new Person("Carlos", 2, 40, Gender.MALE, false);
    RegisterResult result = registry.registerVoter(dead);
    Assert.assertEquals(RegisterResult.DEAD, result);
}
```

### üü¢ GREEN
```java
if (!p.isAlive()) {
    return RegisterResult.DEAD;
}
```

### üîµ REFACTOR
- Reordenamos el orden de validaciones (muerto antes que menor)
- Mejoramos comentarios

---

## Iteraci√≥n 3: Menores de Edad

### üî¥ RED
```java
@Test
public void shouldRejectUnderageAt17() {
    Registry registry = new Registry();
    Person person = new Person("Adolescente", 7, 17, Gender.FEMALE, true);
    RegisterResult result = registry.registerVoter(person);
    Assert.assertEquals(RegisterResult.UNDERAGE, result);
}
```

### üü¢ GREEN
```java
if (p.getAge() < MIN_VALID_AGE) {
    return RegisterResult.UNDERAGE;
}
```

### üîµ REFACTOR
- Verificamos que se valide edad negativa como `INVALID_AGE` antes de `UNDERAGE`
- Descubrimos y corregimos defecto: edad 0 retornaba `UNDERAGE` en lugar de `INVALID_AGE`

---

## Iteraci√≥n 4: Validaci√≥n de ID Inv√°lido

### üî¥ RED
```java
@Test
public void shouldRejectWhenIdIsZero() {
    Registry registry = new Registry();
    Person person = new Person("Carlos", 0, 25, Gender.MALE, true);
    RegisterResult result = registry.registerVoter(person);
    Assert.assertEquals(RegisterResult.INVALID, result);
}
```

### üü¢ GREEN
```java
if (p.getId() < MIN_VALID_ID) {
    return RegisterResult.INVALID;
}
```

### üîµ REFACTOR
- La validaci√≥n ya estaba, solo necesitaba refinar constantes

---

## Iteraci√≥n 5: Validaci√≥n de Edad Inv√°lida

### üî¥ RED
```java
@Test
public void shouldRejectInvalidAgeNegative() {
    Registry registry = new Registry();
    Person person = new Person("Beb√©", 4, -1, Gender.MALE, true);
    RegisterResult result = registry.registerVoter(person);
    Assert.assertEquals(RegisterResult.INVALID_AGE, result);
}

@Test
public void shouldRejectInvalidAgeZero() {
    Registry registry = new Registry();
    Person person = new Person("RecienNacido", 6, 0, Gender.MALE, true);
    RegisterResult result = registry.registerVoter(person);
    Assert.assertEquals(RegisterResult.INVALID_AGE, result);
}
```

### üü¢ GREEN
```java
if (p.getAge() <= 0 || p.getAge() > MAX_VALID_AGE) {
    return RegisterResult.INVALID_AGE;
}
```

### üîµ REFACTOR (Defecto corregido)
- **Defecto encontrado**: Edad 0 retornaba `UNDERAGE` cuando deber√≠a retornar `INVALID_AGE`
- **Causa**: La validaci√≥n de edad negativa era `< 0` en lugar de `<= 0`
- **Soluci√≥n**: Cambiar a `<= 0` para incluir cero como inv√°lido
- Desplazamos esta validaci√≥n ANTES de la validaci√≥n de `UNDERAGE`

---

## Iteraci√≥n 6: Duplicados

### üî¥ RED
```java
@Test
public void shouldRejectDuplicateRegistration() {
    Registry registry = new Registry();
    Person person1 = new Person("Pedro", 100, 30, Gender.MALE, true);
    Person person2 = new Person("Pablo", 100, 35, Gender.MALE, true);
    
    RegisterResult result1 = registry.registerVoter(person1);
    RegisterResult result2 = registry.registerVoter(person2);
    
    Assert.assertEquals(RegisterResult.VALID, result1);
    Assert.assertEquals(RegisterResult.DUPLICATED, result2);
}
```

### üü¢ GREEN
```java
if (registeredIds.contains(p.getId())) {
    return RegisterResult.DUPLICATED;
}
registeredIds.add(p.getId());
```

### üîµ REFACTOR
- Usamos `HashSet<Integer>` para tracking eficiente (O(1))
- Validaci√≥n de duplicados es la √∫ltima (despu√©s de todas las validaciones)

---

## Resumen de Ciclos

| Ciclo | Caracter√≠stica Probada | RED ‚úó | GREEN ‚úì | REFACTOR üîµ |
|-------|------------------------|-------|---------|------------|
| 1 | Persona v√°lida (camino feliz) | Prueba creada | Impl. m√≠nima | Constantes |
| 2 | Persona muerta | Prueba creada | Validaci√≥n alive | Reorden de checks |
| 3 | Menores de edad | Prueba creada | Validaci√≥n edad < 18 | **Defecto corregido** |
| 4 | ID inv√°lido | Prueba creada | Validaci√≥n ID | Constantes MIN_ID |
| 5 | Edad inv√°lida (incl. 0) | 2 pruebas | Validaci√≥n <= 0 | Corregido orden |
| 6 | Duplicados | Prueba creada | HashSet + validaci√≥n | Optimizado (O(1)) |

---

## Defectos Encontrados

### üêõ Defecto 01: Edad 0 retorna UNDERAGE en lugar de INVALID_AGE
- **Encontrado en**: Iteraci√≥n 3/5
- **Causa**: Condici√≥n `age < 0` no inclu√≠a `0`
- **Soluci√≥n**: Cambiar a `age <= 0`
- **Estado**: ‚úÖ RESUELTO

---

## Cobertura de Pruebas

- **Total de pruebas**: 15
- **Todas las pruebas**: ‚úÖ PASAN
- **Cobertura de l√≠nea**: ~100% en Registry.java
- **Clases de equivalencia cubiertas**: 10+
- **Valores l√≠mite**: 8+

---

# Resumen del Taller de TDD

En este taller aplicamos distintas estrategias de **pruebas unitarias** que permiten desarrollar software m√°s confiable, claro y alineado con las reglas de negocio.  

---

## üî¥üü¢üîµ TDD (Test-Driven Development)

- **Qu√© es:** ciclo de desarrollo *Red ‚Üí Green ‚Üí Refactor* en el que primero se escribe una prueba que falla, luego se implementa el c√≥digo m√≠nimo para que pase y finalmente se refactoriza.  
- **Para qu√© sirve:** garantiza que el c√≥digo se construya guiado por pruebas desde el inicio, evitando errores tempranos y facilitando el dise√±o incremental.  

---

## üß© Patr√≥n AAA (Arrange ‚Äì Act ‚Äì Assert)

- **Qu√© es:** forma de estructurar cada prueba en tres pasos:  
  - **Arrange:** preparar los datos y objetos necesarios.  
  - **Act:** ejecutar el m√©todo o acci√≥n bajo prueba.  
  - **Assert:** verificar que el resultado sea el esperado.  
- **Para qu√© sirve:** hace que las pruebas sean m√°s legibles, claras y f√°ciles de mantener, al separar expl√≠citamente la preparaci√≥n, la acci√≥n y la verificaci√≥n.  

---

## üßÆ Clases de Equivalencia y Valores L√≠mite

- **Qu√© es:** t√©cnica de dise√±o de pruebas que agrupa las entradas posibles en clases que se comportan de la misma forma, y selecciona valores representativos (incluyendo bordes).  
- **Para qu√© sirve:** reduce la cantidad de pruebas necesarias sin perder cobertura l√≥gica, asegurando que se validen casos normales, inv√°lidos y extremos donde suelen ocurrir errores.  

---

## ü§ù BDD (Behavior Driven Development)

- **Qu√© es:** forma de expresar pruebas en un lenguaje cercano al negocio usando narrativa **Given ‚Äì When ‚Äì Then (Dado ‚Äì Cuando ‚Äì Entonces)**.  
- **Para qu√© sirve:** conecta las reglas de negocio con la validaci√≥n automatizada, facilitando la comunicaci√≥n entre desarrolladores, analistas y usuarios, y asegurando que las pruebas reflejen el comportamiento esperado del sistema.  

---

## ‚úÖ Conclusi√≥n

En conjunto, estas pr√°cticas permiten:  
- Desarrollar c√≥digo guiado por reglas de negocio (**TDD + BDD**).  
- Escribir pruebas claras y mantenibles (**AAA**).  
- Dise√±ar casos de prueba robustos que cubren diferentes escenarios (**clases de equivalencia y valores l√≠mite**).  

Esto fortalece la **calidad del software**, mejora la **trazabilidad de los requisitos** y fomenta un desarrollo **iterativo y seguro**.

---

# Recursos recomendados
- *The Art of Software Testing* ‚Äì Myers, 2011.  
- *Testing Computer Software* ‚Äì Kaner, 1999.  
- *Effective Unit Testing* ‚Äì Lasse Koskela, 2013.  
